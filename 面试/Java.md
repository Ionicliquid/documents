# AQS
![[Pasted image 20230820200226.png]]
1. 通过一个int同步状态码，和一个队列来控制多个线程访问资源；
	1. 状态值为0（`state=0`）表示没有线程获得锁，通过原子操作修改状态；
	2. 通过双向链表实现FIFO，头节点为哑节点，其他每个节点都会关联一个线程，当上一个资源释放时，按序遍历链表，唤醒线程；
2. 公平/非公平
	1. 非公平：每次都尝试获取锁，失败后直接加入到队列中；
	2. 公平：队列不存在等待的节点时才尝试获取锁；
3. 共享与独占
	1. 独占 只能有一个线程访问
	2. 读写锁
		1.  state 高16为 读锁，低16为写锁；
		2. 写锁为独占锁，有线程获取了写锁的情况，只有同一线程才能获取读锁；
4. 可重入:  `AbstractOwnableSynchronizer#setExclusiveOwnerThread`   与当前获取锁的线程是否相同，相同直接访问
5. CountDownLatch： 计数等待所有线程执行完，也就是state == 0 。
## 参考链接
- [Java并发学习笔记（八）：AQS（AbstractQueuedSynchronizer）、ReentrantLock 原理、读写锁使用和原理\_aqs读写锁原理\_Miracle42的博客-CSDN博客](https://blog.csdn.net/han_zhuang/article/details/106535716)
- [Java并发编程实战: AQS 源码 史上最详尽图解+逐行注释\_51CTO博客\_java aqs源码分析](https://blog.51cto.com/universsky/5898269)
# 线程
1. wait/notify/notifyAll
2. yield:使当前线程从执行状态（运行状态）变为可执行状态（就绪状态）CPU会从众多的可执行状态中选择；
3. join：join方法的实现是通过wait。 当主线程调用t.join时，主线程获得线程对象的锁，调用该对象的wait，直到该对象唤醒main线程，比如推出后，
4. sleep 不会释放锁，可被中断
5. <font color="#ff0000">sychronized</font>
6. volatile
	1. 可见性：线程中读取时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存
	2. 可见性：线程中修改了工作内存中变量的副本，修改之后回立即刷新到主内存
	3. 有序性：若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序
7. 生产者消费者模型
	1.  用while不用if的原因：多个消费者可之间可以互相唤醒，导致判断一直成立
8. 死锁
	1. 互斥条件：资源只能被一个线程持有，其他线程想要使用，只能等待
	2. 请求和保存：线程已经持有了一个资源，但由提出了新的资源请求；
	3. 不剥夺：进程获得的资源只能自己使用完之后释放；
	4. 环路等待：存在一种资源的循环等待链；
9. 三大特性：要想并发程序正确执行必须要保证原子性，可见性和有序性
	1. 原子性：一个操作或多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行；
	2. 可见性：一个线程修改了这个变量的值，其他线程能够立即看到修改的值；
	3. 有序性：即程序执行的顺序按照代码的先后顺序执行；指令重排不会影响当个线程的执行，但是会影响线程并发执行的正确性
## 参考链接
- [并发编程三大特性——原子性、可见性、有序性 - Ye\_yang - 博客园](https://www.cnblogs.com/yeyang/p/13576636.html)
- [谈谈Java中的volatile - dreamcatcher-cx - 博客园](https://www.cnblogs.com/chengxiao/p/6528109.html)
# JVM
## 对象的创建过程
1. 检查类是否被加载
2. 为对象分配内存
	1. 指针碰撞：内存是规整的，指针指向空闲的首地址
	2. 空闲列表：记录哪些内存可用的列表
	3. 保证线程安全  CAS 失败重试/分配缓存：在本地线程上分配
3. 内存空间初始化：设置零值
4. 设置：
	1. 是哪个类的实例
	2. 对象的hash码
	3. 对象的GC分代年龄
5. 对象的初始化
## 类的加载过程
### 加载的时机
遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
1. 使用new关键字实例化对象的时候。
2. 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
3. 调用一个类型的静态方法的时候。
## 双亲委派模型
1. 相同的类
## 其他
### 四大引用
## GCRoots
常见的是前四种
1. 静态变量
2. 线程栈变量
3. 常量池
4. JNI(指针)
5. 内部对象：Class对象、异常对象Exception、类加载器
6. 同步锁，synchronized对象
7. 内部对象
8. 临时对象：跨代引用
## class对象回收条件
1.  class 实例化的所有对象都回收掉了；
2. 对应的类加载 也要被回收掉；
3. 类，Java.lang.class对象被回收
4. 任何地方没有被引用，并且无法通过反射调用这个类的方法；
5. 参数控制（未配置禁用类回收参数）；
# 网络编程
1. 三次握手
	1. 客户端发起连接请求，发送SYN报文，同步序号为x，进入SYN-SEND状态；
	2. 服务端收到SYN报文，回应一个 SYN 和ACK报文，同步序号为y 确认序号为x+1，进入SYN_RECV
	3. 客户端收到服务端的SYN报文，回应一个ACK报文 确认序号为y+1,进入Established状态
2. 四次挥手
	1.  某个应用进程首先调用close, 执行主动关闭，发送一个FIN报文，进入FIN_WAIT_1状态
	2. 对端收到FIN后，
	3. z
	4. c
3. 为什么要三次握手？
	**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。主要防止资源的浪费。**

## 参考连接
1. [TCP是什么？为什么要三次握手四次挥手？ （本文近9千字，建议收藏） - 知乎](https://zhuanlan.zhihu.com/p/128940209)
# 集合
空间与时间的关系
## HashMap
1. 2的幂 让尽可能多的位数参与index的计算
## SparseArray
## ConcurrentHashMap

## 参考链接

- [【Android面试题】2023最新面试专题：网络编程（一） - 掘金](https://juejin.cn/post/7257386139849326653)
- [轻松掌握RecyclerView缓存机制 - 掘金](https://juejin.cn/post/7244452419458777144)
- [Java中的生产者/消费者模型\_java 生产者消费者模型\_青春路上的小蜜蜂的博客-CSDN博客](https://blog.csdn.net/u010257931/article/details/131996016)
- [JVM经典面试题总结(下) - 掘金](https://juejin.cn/post/7268314195299500073)

