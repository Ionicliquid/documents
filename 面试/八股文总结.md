# 1. ThreadLocal ：线程本地变量
1. 每个线程都有单独的ThreadLocalMap 用来保存对应ThreadLocal，通过ThreadLocal存取值实际上时以它为key，操作线程的map;
2. map中的key为ThreadLocal的弱引用，如果触发GC会被被回收，但map对应的value会跟随线程的生命周期；
# 2. 消息机制
## 2.1 Android 消息机制由四个模块组成
1. Looper:轮询器，应用启动时会在主线程中创建Looper，并调用其Loop方法，循环从消息队列中获取消息处理，非主线程的Looper需要用户自己创建和启动；
2. MessageQueue：消息队列，通过ThreadLocal保存在Looper中，负责循环获取消息，没有消息则阻塞等待；
3. Handler：负责发送和处理消息，在创建时会默认使用当前线程的Looper
4. Message: 消息数据，除了携带数据以外，还会记录消息延迟时间，和处理该消息的target Handler，内部维护一个单向的链表的数据结构，按照时间排序；
总结：Looper循环从MessageQueue获取Message, 交给Message对应的Handler处理消息；
## 2.2 同步屏障和异步消息
1. 同步屏障：Message的target为空的消息；
2. 异步消息：消息默认为同步消息，
在View的绘制过程中，首先发送一个同步屏障消息到消息队列中，MessageQueue在遍历消息过程中，发现同步屏障会优先处理异步消息；
？解除屏障
## 2.3 IdleHandler
当消息队列中不存在消息的时候，会遍历IdleHandler列表，一般用来优化启动速度，将非必的步骤移到IdleHandler中去处理
# 3. 事件的传递机制
1. 事件的传递顺序：ViewRootImpl -> DecorView ->Activity -> ViewGroup -> View
2. 一个事件序列由一个DOWN事件 多个MOVE事件和一个cancel或up事件
3. 父View只会对DOWN事件进行分发，并根据手指数量将处理该事件的子View保存在链表中，其他事件则直接在链表中查找View
## Cancel事件的触发机制
### down 事件初始化操作时
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	...
	if (actionMasked == MotionEvent.ACTION_DOWN) {  
		cancelAndClearTouchTargets(ev);  //1
	   resetTouchState();  
	}
	...
}

private void cancelAndClearTouchTargets(MotionEvent event) {  
    if (mFirstTouchTarget != null) {  
        boolean syntheticEvent = false;  
        if (event == null) {  
            final long now = SystemClock.uptimeMillis();  
            event = MotionEvent.obtain(now, now,  
                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);  
            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);  
            syntheticEvent = true;  
        }  
  
        for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {  
            resetCancelNextUpFlag(target.child);  
            dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);  // 1.1
        }  
        clearTouchTargets();  
  
        if (syntheticEvent) {  
            event.recycle();  
        }  
    }  
}
```
### 在子View处理事件的过程中，父View对事件进行拦截
已有子View处理了Down事件（mFirstTouchTarget != null），但后续事件被拦截
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	...
if (actionMasked == MotionEvent.ACTION_DOWN  
        || mFirstTouchTarget != null) {  //2
    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  
    if (!disallowIntercept) {  
        intercepted = onInterceptTouchEvent(ev);  
        ev.setAction(action); // restore action in case it was changed  
    } else {  
        intercepted = false;  
    }  
} else {  
  intercepted = true;  
}
	...
}

```

### 子View被设置了PFLAG_CANCEL_NEXT_UP_EVENT标志位
除了事件被拦截外，如果子View设置了PFLAG_CANCEL_NEXT_UP_EVENT标记位，也会产生cancel事件
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	// Dispatch to touch targets.  
if (mFirstTouchTarget == null) {  
    handled = dispatchTransformedTouchEvent(ev, canceled, null,  
            TouchTarget.ALL_POINTER_IDS);  
} else {  
	 TouchTarget predecessor = null;  
    TouchTarget target = mFirstTouchTarget;  
    while (target != null) {  
        final TouchTarget next = target.next;  
        if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {  
            handled = true;  
        } else {  
            final boolean cancelChild = resetCancelNextUpFlag(target.child)  
                    || intercepted;  //3
            if (dispatchTransformedTouchEvent(ev, cancelChild,  
                    target.child, target.pointerIdBits)) {  
                handled = true;  
            }  
            if (cancelChild) {  
                if (predecessor == null) {  
                    mFirstTouchTarget = next;  
                } else {  
                    predecessor.next = next;  
                }  
                target.recycle();  
                target = next;  
                continue;            }  
        }  
        predecessor = target;  
        target = next;  
    }  
}
}
private static boolean resetCancelNextUpFlag(@NonNull View view) {  
    if ((view.mPrivateFlags & PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {  
        view.mPrivateFlags &= ~PFLAG_CANCEL_NEXT_UP_EVENT;  
        return true;    }  
    return false;  
}
```

### 在子View处理事件的过程中被父View移除
当ViewGroup移除子View时，如果View在链表中，将会下发Cancel事件；
``` java
private void cancelTouchTarget(View view) {  
    TouchTarget predecessor = null;  
    TouchTarget target = mFirstTouchTarget;  
    while (target != null) {  
        final TouchTarget next = target.next;  
        if (target.child == view) {  
            if (predecessor == null) {  
                mFirstTouchTarget = next;  
            } else {  
                predecessor.next = next;  
            }  
            target.recycle();  
  
            final long now = SystemClock.uptimeMillis();  
            MotionEvent event = MotionEvent.obtain(now, now,  
                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);  
            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);  
            view.dispatchTouchEvent(event);  //4
            event.recycle();  
            return;        }  
        predecessor = target;  
        target = next;  
    }  
}
```
### 参考链接
[Android中ACTION\_CANCEl的触发机制 - 简书](https://www.jianshu.com/p/3af774e9aedd)
# 4. Jetpack
## Lifecycle
Lifecycle 时基于观察者模式的推模型实现，当被观察者发生变化，通知所有的观察者；
1. Activity 会实现LifecycleOwner接口，创建并返回LifecycleRegistry对象。
2. LifecycleRegistry会通过map ，保存所有观察者对象，也就是LifecycleObserver，当Activity的生命周期发生变化时，遍历map通知所有的观察者；
3. 事件驱动状态变化：
``` java
//Lifecycle
public State getTargetState() {  
    switch (this) {  
        case ON_CREATE:  
        case ON_STOP:  
            return State.CREATED;  
        case ON_START:  
        case ON_PAUSE:  
            return State.STARTED;  
        case ON_RESUME:  
            return State.RESUMED;  
        case ON_DESTROY:  
            return State.DESTROYED;  
        case ON_ANY:  
            break;  
    }  
    throw new IllegalArgumentException(this + " has no target state");  
}

public static Event downFrom(@NonNull State state) {  
    switch (state) {  
        case CREATED:  
            return ON_DESTROY;  
        case STARTED:  
            return ON_STOP;  
        case RESUMED:  
            return ON_PAUSE;  
        default:  
            return null;  
    }  
}

//LifecycleRegistry
public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {  
    enforceMainThreadIfNeeded("handleLifecycleEvent");  
    moveToState(event.getTargetState());  
}  
  
private void moveToState(State next) {  
    if (mState == next) {  
        return;  
    }  
    mState = next;  
    if (mHandlingEvent || mAddingObserverCounter != 0) {  
        mNewEventOccurred = true;  
        // we will figure out what to do on upper level.  
        return;  
    }  
    mHandlingEvent = true;  
    sync();  
    mHandlingEvent = false;  
}
}
private void sync() {  
    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();  
    if (lifecycleOwner == null) {  
        throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already"  
                + "garbage collected. It is too late to change lifecycle state.");  
    }  
    while (!isSynced()) {  
        mNewEventOccurred = false;  
   
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {  
            backwardPass(lifecycleOwner);  
        }  
        Map.Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();  
        if (!mNewEventOccurred && newest != null  
                && mState.compareTo(newest.getValue().mState) > 0) {  
            forwardPass(lifecycleOwner);  
        }  
    }  
    mNewEventOccurred = false;  
}
private void backwardPass(LifecycleOwner lifecycleOwner) {  
    Iterator<Map.Entry<LifecycleObserver, ObserverWithState>> descendingIterator =  
            mObserverMap.descendingIterator();  
    while (descendingIterator.hasNext() && !mNewEventOccurred) {  
        Map.Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();  
        ObserverWithState observer = entry.getValue();  
        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred  
                && mObserverMap.contains(entry.getKey()))) {  
            Event event = Event.downFrom(observer.mState);  
            if (event == null) {  
                throw new IllegalStateException("no event down from " + observer.mState);  
            }  
            pushParentState(event.getTargetState());  
            observer.dispatchEvent(lifecycleOwner, event);  
            popParentState();  
        }  
    }  
}
```

## 4.2 LiveData
与Lifecycle 类似，LiveData也会保存观察者列表，setValue时，会遍历所有的观察者列表通知，并对齐观察者与LiveData的数据版本号；
``` java
private SafeIterableMap<Observer<? super T>, ObserverWrapper> mObservers =  
        new SafeIterableMap<>();
protected void setValue(T value) {  
    assertMainThread("setValue");  
    mVersion++;  
    mData = value;  
    dispatchingValue(null);  
}
void dispatchingValue(@Nullable ObserverWrapper initiator) {  
    if (mDispatchingValue) {  
        mDispatchInvalidated = true;  
        return;    }  
    mDispatchingValue = true;  
    do {  
        mDispatchInvalidated = false;  
        if (initiator != null) {  
            considerNotify(initiator);  
            initiator = null;  
        } else {  
            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =  
                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {  
                considerNotify(iterator.next().getValue());  
                if (mDispatchInvalidated) {  
                    break;  
                }  
            }  
        }  
    } while (mDispatchInvalidated);  
    mDispatchingValue = false;  
}
private void considerNotify(ObserverWrapper observer) {  
    if (!observer.mActive) {  
        return;  
    }  
    if (!observer.shouldBeActive()) {  
        observer.activeStateChanged(false);  
        return;    }  
    if (observer.mLastVersion >= mVersion) {  
        return;  
    }  
    observer.mLastVersion = mVersion;  
    observer.mObserver.onChanged((T) mData);  
}
```
### 4.2.1 粘性数据
1. 通常在使用LiveData时，会与Lifecycle绑定，这样LiveData就可以监听到Activity的生命周期变化，用来保证只在页面onResume时更新数据;
2. 接受到onResume事件，触发状态更新，当前观察者的数据版本号比当前Livedata的版本号小，所以总是会接受到最后一次数据；
3. 解决办法就是通过反射，修改观察者的版本号；
``` java
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {  
    assertMainThread("observe");  
    if (owner.getLifecycle().getCurrentState() == DESTROYED) {  
        // ignore  
        return;  
    }  
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);  
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);  
    if (existing != null && !existing.isAttachedTo(owner)) {  
        throw new IllegalArgumentException("Cannot add the same observer"  
                + " with different lifecycles");  
    }  
    if (existing != null) {  
        return;  
    }  
    owner.getLifecycle().addObserver(wrapper);  
}
// LifecycleBoundObserver
public void onStateChanged(@NonNull LifecycleOwner source,  
        @NonNull Lifecycle.Event event) {  
    Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();  
    if (currentState == DESTROYED) {  
        removeObserver(mObserver);  
        return;    }  
    Lifecycle.State prevState = null;  
    while (prevState != currentState) {  
        prevState = currentState;  
        activeStateChanged(shouldBeActive());  
        currentState = mOwner.getLifecycle().getCurrentState();  
    }  
}
private void hook(Observer<? super T> observer) {  
    try {  
        // TODO 1.得到mLastVersion  
        // 获取到LivData的类中的mObservers对象  
        Class<LiveData> liveDataClass = LiveData.class;  
        Field mObserversField = liveDataClass.getDeclaredField("mObservers");  
        mObserversField.setAccessible(true);  
        // 获取到这个成员变量的对象  
        Object mObserversObject = mObserversField.get(this);  
        // 得到map对象的class对象  
        Class<?> mObserversClass = mObserversObject.getClass();  
        // 获取到mObservers对象的get方法  
        Method get = mObserversClass.getDeclaredMethod("get", Object.class);  
        get.setAccessible(true);  
        // 执行get方法  
        Object invokeEntry = get.invoke(mObserversObject, observer);  
        // 取到entry中的value  
        Object observerWraper = null;  
        if (invokeEntry != null && invokeEntry instanceof Map.Entry) {  
            observerWraper = ((Map.Entry) invokeEntry).getValue();  
        }  
        if (observerWraper == null) {  
            throw new NullPointerException("observerWraper is null");  
        }  
        // 得到observerWraperr的类对象  
        Class<?> supperClass = observerWraper.getClass().getSuperclass();  
        Field mLastVersion = supperClass.getDeclaredField("mLastVersion");  
        mLastVersion.setAccessible(true);  
  
        // TODO 2.得到mVersion  
        Field mVersion = liveDataClass.getDeclaredField("mVersion");  
        mVersion.setAccessible(true);  
  
        // TODO 3.mLastVersion=mVersion  
        Object mVersionValue = mVersion.get(this);  
        mLastVersion.set(observerWraper, mVersionValue);  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
}

```
## 4.3 ViewModel
Activity同样会实现ViewModelStoreOwner接口，用来创建ViewModelStore对象, 通过map来保存所有的ViewModel；
Activity会实现onRetainNonConfigurationInstance方法，保存ViewModelStore，当Configuration变化触发Activity重启时用来恢复数据；
## 4.4 DataBinding
1. 将DataBingding生成的xml 拆分成2个xml文件,  一部分为布局文件，并且为每个绑定的View指定tag,一部分为数据文件，通过tag记录数据与View的对应关系；

# 5. MMKV
## 5.1 优势
1. mmap防止数据丢失， 提升读写效率；
2. 精简数据，以最少的数据量表示最多的信息，减少数据大小
3. 增量更新，避免每次进行全量写入；
## 5.2 mmap
## 5.3 protobuf
# 6. 线程池
## 流程
1. 判断核心线程数是否已满，如果没有，则创建线程执行任务；
2. 如果核心线程已满，判断队列是否已满，如果队列没满，则将任务放在队列中；
3. 如果队列已满，则判断你线程池是否已满，如果没满，则创建线程执行任务；
4. 如果线程池也满了，则按照拒绝策略对任务进行处理；
## 参考链接
- [线程池技术之：ThreadPoolExecutor 源码解析](https://www.cnblogs.com/yougewe/p/12267274.html)
# 7. 线程
## 7.1 关键字
### yield
使当前线程从执行状态（运行状态）变成可执行状态（就绪状态）。CPU会从众多的可执行状态中选择；
### join
join方法的实现是通过wait。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait意味着拿到该对象的锁），调用该对象的wait（等待时间）。知道该对象唤醒main线程，比如退出后。这就意味者main线程调用join时，必须能够拿到线程t对象的锁。
``` java
public final void join(long millis)  
throws InterruptedException {  
    synchronized(lock) {  
    long base = System.currentTimeMillis();  
    long now = 0;  
  
    if (millis < 0) {  
        throw new IllegalArgumentException("timeout value is negative");  
    }  
  
    if (millis == 0) {  
        while (isAlive()) {  
            lock.wait(0);  
        }  
    } else {  
        while (isAlive()) {  
            long delay = millis - now;  
            if (delay <= 0) {  
                break;  
            }  
            lock.wait(delay);  
            now = System.currentTimeMillis() - base;  
        }  
    }  
    }  
}
```
### wait
wait必须在synchronized代码块中，同时释放对象的锁，等待notify/notifyAll 或者等待超时后重新获取的锁继续执行；
### sleep
sleep阻塞当前线程，不会释放锁。
### CAS
### synchronized
### volitale
# 8. 插件化
## 插件化换肤
### 拦截 View的创建过程
1. LayoutInflater 在通过反射创建View过程中，预留了接口（ Factory/Factory2）允许用户自定义创建过程；
2. Factory只允许被设置一次AppCompatActivity已经设置了一次，，Android 11之前都可以通过反射来修改mFactorySet值，现在我们只能在调用父类onCreate之前来设置Factory；
``` java
//LayoutInflater
public final View tryCreateView(@Nullable View parent, @NonNull String name,  
@NonNull Context context,  
@NonNull AttributeSet attrs) {  
    if (name.equals(TAG_1995)) {  
        // Let's party like it's 1995!  
        return new BlinkLayout(context, attrs);  
    }  
  
    View view;  
    if (mFactory2 != null) {  
        view = mFactory2.onCreateView(parent, name, context, attrs); //1 
    } else if (mFactory != null) {  
        view = mFactory.onCreateView(name, context, attrs);  
    } else {  
        view = null;  
    }  
  
    if (view == null && mPrivateFactory != null) {  
        view = mPrivateFactory.onCreateView(parent, name, context, attrs);  
    }  
    return view;  
}
public void setFactory2(Factory2 factory) {  
    if (mFactorySet) {  //2
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");  
    }  
    if (factory == null) {  
        throw new NullPointerException("Given factory can not be null");  
    }  
    mFactorySet = true;  
    if (mFactory == null) {  
        mFactory = mFactory2 = factory;  
    } else {  
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);  
    }  
}
```
### 加载插件的资源
参考原生的资源加载方式，直接利用插件apk路径 生成的AssetManager 构建Resource
``` java
public void loadSkin(String skinPath) {  
    if (TextUtils.isEmpty(skinPath)) {  
        //还原默认皮肤  
        SkinPreference.getInstance().reset();  
        SkinResources.getInstance().reset();  
    } else {  
        try {  
            //反射创建AssetManager 与 Resource        
            AssetManager assetManager = AssetManager.class.newInstance();  
            //资源路径设置 目录或压缩包  
            Method addAssetPath = assetManager.getClass().getMethod("addAssetPath",  
                    String.class);  
            addAssetPath.invoke(assetManager, skinPath);  
  
            //宿主app的 resources;            
            Resources appResource = mContext.getResources();  
            //根据当前的设备显示器信息 与 配置(横竖屏、语言等) 创建Resources  
            Resources skinResource = new Resources(assetManager, appResource.getDisplayMetrics(),  
                    appResource.getConfiguration());  
  
            //获取外部Apk(皮肤包) 包名  
            PackageManager mPm = mContext.getPackageManager();  
            PackageInfo info = mPm.getPackageArchiveInfo(skinPath, PackageManager.GET_ACTIVITIES);  
            String packageName = info.packageName;  
            SkinResources.getInstance().applySkin(skinResource, packageName);  
  
            //记录路径  
            SkinPreference.getInstance().setSkin(skinPath);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
    //通知采集的View 更新皮肤  
    //被观察者改变 通知所有观察者  
    setChanged();  
    notifyObservers(null);  
}
```
### 保存View与支持动态修改的属性列表mSkinViews
```java
private static final List<String> mAttributes = new ArrayList<>();  
  
static {  
    mAttributes.add("background");  
    mAttributes.add("src");  
    mAttributes.add("textColor");  
    mAttributes.add("drawableLeft");  
    mAttributes.add("drawableTop");  
    mAttributes.add("drawableRight");  
    mAttributes.add("drawableBottom");  
}
public void look(View view, AttributeSet attrs) {  
    List<SkinPair> mSkinPars = new ArrayList<>();  
  
    for (int i = 0; i < attrs.getAttributeCount(); i++) {  
        //获得属性名  textColor/background        String attributeName = attrs.getAttributeName(i);  
  
        if (mAttributes.contains(attributeName)) {  
            // 获取属性值  
            String attributeValue = attrs.getAttributeValue(i);  
            // 比如color 以#开头表示写死的颜色 不可用于换肤  
            if (attributeValue.startsWith("#")) {  
                continue;  
            }  
            int resId;  
            // 以 ？开头的表示使用 属性  
            if (attributeValue.startsWith("?")) {  
                int attrId = Integer.parseInt(attributeValue.substring(1));  
                resId = SkinThemeUtils.getResId(view.getContext(), new int[]{attrId})[0];  
            } else {  
                // 正常以 @ 开头  
                resId = Integer.parseInt(attributeValue.substring(1));  
            }  
            SkinPair skinPair = new SkinPair(attributeName, resId);  
            mSkinPars.add(skinPair);  
        }  
    }  
  
    if (!mSkinPars.isEmpty() || view instanceof SkinViewSupport) {  
        SkinView skinView = new SkinView(view, mSkinPars);  
        // 如果选择过皮肤 ，调用 一次 applySkin 加载皮肤的资源  
        skinView.applySkin();  
        mSkinViews.add(skinView);  
    }  
}
```
## 利用属性名称和类型在插件Resource中查找资源;
已知资源id 可以查找到对应的名称和类型，反之也可以查到对应的id；
``` java
public void applySkin() {  
    applySkinSupport();  
    for (SkinPair skinPair : skinPairs) {  
        Drawable left = null, top = null, right = null, bottom = null;  
        switch (skinPair.attributeName) {  
            case "background":  
                Object background = SkinResources.getInstance().getBackground(skinPair  
                        .resId);  
                //背景可能是 @color 也可能是 @drawable               
                 if (background instanceof Integer) {  
                    view.setBackgroundColor((int) background);  
                } else {  
                    ViewCompat.setBackground(view, (Drawable) background);  
                }  
                break;  
            case "src":  
                background = SkinResources.getInstance().getBackground(skinPair  
                        .resId);  
                if (background instanceof Integer) {  
                    ((ImageView) view).setImageDrawable(new ColorDrawable((Integer)  
                            background));  
                } else {  
                    ((ImageView) view).setImageDrawable((Drawable) background);  
                }  
                break;  
            case "textColor":  
                ((TextView) view).setTextColor(SkinResources.getInstance().getColorStateList  
                        (skinPair.resId));  
                break;            case "drawableLeft":  
                left = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableTop":  
                top = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableRight":  
                right = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableBottom":  
                bottom = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            default:  
                break;  
        }  
        if (null != left || null != right || null != top || null != bottom) {  
            ((TextView) view).setCompoundDrawablesWithIntrinsicBounds(left, top, right,  
                    bottom);  
        }  
    }  
}

public int getIdentifier(int resId){  
    if(isDefaultSkin){  
        return resId;  
    }  
    String resName=mAppResources.getResourceEntryName(resId);  
    String resType=mAppResources.getResourceTypeName(resId);  
    int skinId=mSkinResources.getIdentifier(resName,resType,mSkinPkgName);  
    return skinId;  
}  
  
/**  
 * 输入主APP的ID，到皮肤APK文件中去找到对应ID的颜色值  
 * @param resId  
 * @return  
 */  
public int getColor(int resId){  
    if(isDefaultSkin){  
        return mAppResources.getColor(resId);  
    }  
    int skinId=getIdentifier(resId);  
    if(skinId==0){  
        return mAppResources.getColor(resId);  
    }  
    return mSkinResources.getColor(skinId);  
}  
  
public ColorStateList getColorStateList(int resId) {  
    if (isDefaultSkin) {  
        return mAppResources.getColorStateList(resId);  
    }  
    int skinId = getIdentifier(resId);  
    if (skinId == 0) {  
        return mAppResources.getColorStateList(resId);  
    }  
    return mSkinResources.getColorStateList(skinId);  
}  
  
public Drawable getDrawable(int resId) {  
    if (isDefaultSkin) {  
        return mAppResources.getDrawable(resId);  
    }  
    //通过 app的resource 获取id 对应的 资源名 与 资源类型  
    //找到 皮肤包 匹配 的 资源名资源类型 的 皮肤包的 资源 ID  
      int skinId = getIdentifier(resId);  
    if (skinId == 0) {  
        return mAppResources.getDrawable(resId);  
    }  
    return mSkinResources.getDrawable(skinId);  
}

public Object getBackground(int resId) {  
    String resourceTypeName = mAppResources.getResourceTypeName(resId);  
  
    if ("color".equals(resourceTypeName)) {  
        return getColor(resId);  
    } else {  
        // drawable  
        return getDrawable(resId);  
    }  
}
```
## 双亲委派机制
1. 资源冲突: 1. 同名冲突 2继承带来的冲突？
2. Dropplugin 处理？
## 加载Activity
## 加载资源
# 9. 热修复
# 10. View
## RecyclerView
### 缓存机制
# 11. 开源框架
## Okhttp
# Frameworks
## Activity的启动流程
