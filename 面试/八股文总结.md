# 1. ThreadLocal ：线程本地变量
1. 每个线程都有单独的ThreadLocalMap 用来保存对应ThreadLocal，通过ThreadLocal存取值实际上时以它为key，操作线程的map;
2. map中的key为ThreadLocal的弱引用，如果触发GC会被被回收，但map对应的value会跟随线程的生命周期；
# 2. 消息机制
## 2.1 Android 消息机制由四个模块组成
1. Looper:轮询器，应用启动时会在主线程中创建Looper，并调用其Loop方法，循环从消息队列中获取消息处理，非主线程的Looper需要用户自己创建和启动；
2. MessageQueue：消息队列，通过ThreadLocal保存在Looper中，负责循环获取消息，没有消息则阻塞等待；
3. Handler：负责发送和处理消息，在创建时会默认使用当前线程的Looper
4. Message: 消息数据，除了携带数据以外，还会记录消息延迟时间，和处理该消息的target Handler，内部维护一个单向的链表的数据结构，按照时间排序；
总结：Looper循环从MessageQueue获取Message, 交给Message对应的Handler处理消息；
## 2.2 同步屏障和异步消息
1. 同步屏障：Message的target为空的消息；
2. 异步消息：消息默认为同步消息，
在View的绘制过程中，首先发送一个同步屏障消息到消息队列中，MessageQueue在遍历消息过程中，发现同步屏障会优先处理异步消息；
？解除屏障
## 2.3 IdleHandler
当消息队列中不存在消息的时候，会遍历IdleHandler列表，一般用来优化启动速度，将非必的步骤移到IdleHandler中去处理
# 3. 事件的传递机制
1. 事件的传递顺序：ViewRootImpl -> DecorView ->Activity -> ViewGroup -> View
2. 一个事件序列由一个DOWN事件 多个MOVE事件和一个cancel或up事件
3. 父View只会对DOWN事件进行分发，并根据手指数量将处理该事件的子View保存在链表中，其他事件则直接在链表中查找View
## Cancel事件的触发机制
### down 事件初始化操作时
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	...
	if (actionMasked == MotionEvent.ACTION_DOWN) {  
		cancelAndClearTouchTargets(ev);  //1
	   resetTouchState();  
	}
	...
}

private void cancelAndClearTouchTargets(MotionEvent event) {  
    if (mFirstTouchTarget != null) {  
        boolean syntheticEvent = false;  
        if (event == null) {  
            final long now = SystemClock.uptimeMillis();  
            event = MotionEvent.obtain(now, now,  
                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);  
            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);  
            syntheticEvent = true;  
        }  
  
        for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {  
            resetCancelNextUpFlag(target.child);  
            dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);  // 1.1
        }  
        clearTouchTargets();  
  
        if (syntheticEvent) {  
            event.recycle();  
        }  
    }  
}
```
### 在子View处理事件的过程中，父View对事件进行拦截
已有子View处理了Down事件（mFirstTouchTarget != null），但后续事件被拦截
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	...
if (actionMasked == MotionEvent.ACTION_DOWN  
        || mFirstTouchTarget != null) {  //2
    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  
    if (!disallowIntercept) {  
        intercepted = onInterceptTouchEvent(ev);  
        ev.setAction(action); // restore action in case it was changed  
    } else {  
        intercepted = false;  
    }  
} else {  
  intercepted = true;  
}
	...
}

```

### 子View被设置了PFLAG_CANCEL_NEXT_UP_EVENT标志位
除了事件被拦截外，如果子View设置了PFLAG_CANCEL_NEXT_UP_EVENT标记位，也会产生cancel事件
``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
	// Dispatch to touch targets.  
if (mFirstTouchTarget == null) {  
    handled = dispatchTransformedTouchEvent(ev, canceled, null,  
            TouchTarget.ALL_POINTER_IDS);  
} else {  
	 TouchTarget predecessor = null;  
    TouchTarget target = mFirstTouchTarget;  
    while (target != null) {  
        final TouchTarget next = target.next;  
        if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {  
            handled = true;  
        } else {  
            final boolean cancelChild = resetCancelNextUpFlag(target.child)  
                    || intercepted;  //3
            if (dispatchTransformedTouchEvent(ev, cancelChild,  
                    target.child, target.pointerIdBits)) {  
                handled = true;  
            }  
            if (cancelChild) {  
                if (predecessor == null) {  
                    mFirstTouchTarget = next;  
                } else {  
                    predecessor.next = next;  
                }  
                target.recycle();  
                target = next;  
                continue;            }  
        }  
        predecessor = target;  
        target = next;  
    }  
}
}
private static boolean resetCancelNextUpFlag(@NonNull View view) {  
    if ((view.mPrivateFlags & PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {  
        view.mPrivateFlags &= ~PFLAG_CANCEL_NEXT_UP_EVENT;  
        return true;    }  
    return false;  
}
```

### 在子View处理事件的过程中被父View移除
当ViewGroup移除子View时，如果View在链表中，将会下发Cancel事件；
``` java
private void cancelTouchTarget(View view) {  
    TouchTarget predecessor = null;  
    TouchTarget target = mFirstTouchTarget;  
    while (target != null) {  
        final TouchTarget next = target.next;  
        if (target.child == view) {  
            if (predecessor == null) {  
                mFirstTouchTarget = next;  
            } else {  
                predecessor.next = next;  
            }  
            target.recycle();  
  
            final long now = SystemClock.uptimeMillis();  
            MotionEvent event = MotionEvent.obtain(now, now,  
                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);  
            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);  
            view.dispatchTouchEvent(event);  //4
            event.recycle();  
            return;        }  
        predecessor = target;  
        target = next;  
    }  
}
```
### 参考链接
[Android中ACTION\_CANCEl的触发机制 - 简书](https://www.jianshu.com/p/3af774e9aedd)
# 4. Jetpack
## Lifecycle
Lifecycle 时基于观察者模式的推模型实现，当被观察者发生变化，通知所有的观察者；
1. Activity 会实现LifecycleOwner接口，创建并返回LifecycleRegistry对象。
2. LifecycleRegistry会通过map ，保存所有观察者对象，也就是LifecycleObserver，当Activity的生命周期发生变化时，遍历map通知所有的观察者；
3. 事件驱动状态变化：
``` java
//Lifecycle
public State getTargetState() {  
    switch (this) {  
        case ON_CREATE:  
        case ON_STOP:  
            return State.CREATED;  
        case ON_START:  
        case ON_PAUSE:  
            return State.STARTED;  
        case ON_RESUME:  
            return State.RESUMED;  
        case ON_DESTROY:  
            return State.DESTROYED;  
        case ON_ANY:  
            break;  
    }  
    throw new IllegalArgumentException(this + " has no target state");  
}

public static Event downFrom(@NonNull State state) {  
    switch (state) {  
        case CREATED:  
            return ON_DESTROY;  
        case STARTED:  
            return ON_STOP;  
        case RESUMED:  
            return ON_PAUSE;  
        default:  
            return null;  
    }  
}

//LifecycleRegistry
public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {  
    enforceMainThreadIfNeeded("handleLifecycleEvent");  
    moveToState(event.getTargetState());  
}  
  
private void moveToState(State next) {  
    if (mState == next) {  
        return;  
    }  
    mState = next;  
    if (mHandlingEvent || mAddingObserverCounter != 0) {  
        mNewEventOccurred = true;  
        // we will figure out what to do on upper level.  
        return;  
    }  
    mHandlingEvent = true;  
    sync();  
    mHandlingEvent = false;  
}
}
private void sync() {  
    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();  
    if (lifecycleOwner == null) {  
        throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already"  
                + "garbage collected. It is too late to change lifecycle state.");  
    }  
    while (!isSynced()) {  
        mNewEventOccurred = false;  
   
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {  
            backwardPass(lifecycleOwner);  
        }  
        Map.Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();  
        if (!mNewEventOccurred && newest != null  
                && mState.compareTo(newest.getValue().mState) > 0) {  
            forwardPass(lifecycleOwner);  
        }  
    }  
    mNewEventOccurred = false;  
}
private void backwardPass(LifecycleOwner lifecycleOwner) {  
    Iterator<Map.Entry<LifecycleObserver, ObserverWithState>> descendingIterator =  
            mObserverMap.descendingIterator();  
    while (descendingIterator.hasNext() && !mNewEventOccurred) {  
        Map.Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();  
        ObserverWithState observer = entry.getValue();  
        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred  
                && mObserverMap.contains(entry.getKey()))) {  
            Event event = Event.downFrom(observer.mState);  
            if (event == null) {  
                throw new IllegalStateException("no event down from " + observer.mState);  
            }  
            pushParentState(event.getTargetState());  
            observer.dispatchEvent(lifecycleOwner, event);  
            popParentState();  
        }  
    }  
}
```

## 4.2 LiveData
与Lifecycle 类似，LiveData也会保存观察者列表，setValue时，会遍历所有的观察者列表通知，并对齐观察者与LiveData的数据版本号；
``` java
private SafeIterableMap<Observer<? super T>, ObserverWrapper> mObservers =  
        new SafeIterableMap<>();
protected void setValue(T value) {  
    assertMainThread("setValue");  
    mVersion++;  
    mData = value;  
    dispatchingValue(null);  
}
void dispatchingValue(@Nullable ObserverWrapper initiator) {  
    if (mDispatchingValue) {  
        mDispatchInvalidated = true;  
        return;    }  
    mDispatchingValue = true;  
    do {  
        mDispatchInvalidated = false;  
        if (initiator != null) {  
            considerNotify(initiator);  
            initiator = null;  
        } else {  
            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =  
                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {  
                considerNotify(iterator.next().getValue());  
                if (mDispatchInvalidated) {  
                    break;  
                }  
            }  
        }  
    } while (mDispatchInvalidated);  
    mDispatchingValue = false;  
}
private void considerNotify(ObserverWrapper observer) {  
    if (!observer.mActive) {  
        return;  
    }  
    if (!observer.shouldBeActive()) {  
        observer.activeStateChanged(false);  
        return;    }  
    if (observer.mLastVersion >= mVersion) {  
        return;  
    }  
    observer.mLastVersion = mVersion;  
    observer.mObserver.onChanged((T) mData);  
}
```
### 4.2.1 粘性数据
1. 通常在使用LiveData时，会与Lifecycle绑定，这样LiveData就可以监听到Activity的生命周期变化，用来保证只在页面onResume时更新数据;
2. 接受到onResume事件，触发状态更新，当前观察者的数据版本号比当前Livedata的版本号小，所以总是会接受到最后一次数据；
3. 解决办法就是通过反射，修改观察者的版本号；
``` java
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {  
    assertMainThread("observe");  
    if (owner.getLifecycle().getCurrentState() == DESTROYED) {  
        // ignore  
        return;  
    }  
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);  
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);  
    if (existing != null && !existing.isAttachedTo(owner)) {  
        throw new IllegalArgumentException("Cannot add the same observer"  
                + " with different lifecycles");  
    }  
    if (existing != null) {  
        return;  
    }  
    owner.getLifecycle().addObserver(wrapper);  
}
// LifecycleBoundObserver
public void onStateChanged(@NonNull LifecycleOwner source,  
        @NonNull Lifecycle.Event event) {  
    Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();  
    if (currentState == DESTROYED) {  
        removeObserver(mObserver);  
        return;    }  
    Lifecycle.State prevState = null;  
    while (prevState != currentState) {  
        prevState = currentState;  
        activeStateChanged(shouldBeActive());  
        currentState = mOwner.getLifecycle().getCurrentState();  
    }  
}
private void hook(Observer<? super T> observer) {  
    try {  
        // TODO 1.得到mLastVersion  
        // 获取到LivData的类中的mObservers对象  
        Class<LiveData> liveDataClass = LiveData.class;  
        Field mObserversField = liveDataClass.getDeclaredField("mObservers");  
        mObserversField.setAccessible(true);  
        // 获取到这个成员变量的对象  
        Object mObserversObject = mObserversField.get(this);  
        // 得到map对象的class对象  
        Class<?> mObserversClass = mObserversObject.getClass();  
        // 获取到mObservers对象的get方法  
        Method get = mObserversClass.getDeclaredMethod("get", Object.class);  
        get.setAccessible(true);  
        // 执行get方法  
        Object invokeEntry = get.invoke(mObserversObject, observer);  
        // 取到entry中的value  
        Object observerWraper = null;  
        if (invokeEntry != null && invokeEntry instanceof Map.Entry) {  
            observerWraper = ((Map.Entry) invokeEntry).getValue();  
        }  
        if (observerWraper == null) {  
            throw new NullPointerException("observerWraper is null");  
        }  
        // 得到observerWraperr的类对象  
        Class<?> supperClass = observerWraper.getClass().getSuperclass();  
        Field mLastVersion = supperClass.getDeclaredField("mLastVersion");  
        mLastVersion.setAccessible(true);  
  
        // TODO 2.得到mVersion  
        Field mVersion = liveDataClass.getDeclaredField("mVersion");  
        mVersion.setAccessible(true);  
  
        // TODO 3.mLastVersion=mVersion  
        Object mVersionValue = mVersion.get(this);  
        mLastVersion.set(observerWraper, mVersionValue);  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
}

```
## 4.3 ViewModel
Activity同样会实现ViewModelStoreOwner接口，用来创建ViewModelStore对象, 通过map来保存所有的ViewModel；
Activity会实现onRetainNonConfigurationInstance方法，保存ViewModelStore，当Configuration变化触发Activity重启时用来恢复数据；
## 4.4 DataBinding
1. 将DataBingding生成的xml 拆分成2个xml文件,  一部分为布局文件，并且为每个绑定的View指定tag,一部分为数据文件，通过tag记录数据与View的对应关系；

# MMKV
## 5.1 优势
1. mmap防止数据丢失， 提升读写效率；
2. 精简数据，以最少的数据量表示最多的信息，减少数据大小
3. 增量更新，避免每次进行全量写入；
## 5.2 mmap
## 5.3 protobuf
# 6. 线程池
## 流程
1. 判断核心线程数是否已满，如果没有，则创建线程执行任务；
2. 如果核心线程已满，判断队列是否已满，如果队列没满，则将任务放在队列中；
3. 如果队列已满，则判断你线程池是否已满，如果没满，则创建线程执行任务；
4. 如果线程池也满了，则按照拒绝策略对任务进行处理；
## 参考链接
- [线程池技术之：ThreadPoolExecutor 源码解析](https://www.cnblogs.com/yougewe/p/12267274.html)
# 7. 线程
## 关键字
### yield
使当前线程从执行状态（运行状态）变成可执行状态（就绪状态）。CPU会从众多的可执行状态中选择；
### join
join方法的实现是通过wait。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait意味着拿到该对象的锁），调用该对象的wait（等待时间）。知道该对象唤醒main线程，比如退出后。这就意味者main线程调用join时，必须能够拿到线程t对象的锁。
``` java
public final void join(long millis)  
throws InterruptedException {  
    synchronized(lock) {  
    long base = System.currentTimeMillis();  
    long now = 0;  
  
    if (millis < 0) {  
        throw new IllegalArgumentException("timeout value is negative");  
    }  
  
    if (millis == 0) {  
        while (isAlive()) {  
            lock.wait(0);  
        }  
    } else {  
        while (isAlive()) {  
            long delay = millis - now;  
            if (delay <= 0) {  
                break;  
            }  
            lock.wait(delay);  
            now = System.currentTimeMillis() - base;  
        }  
    }  
    }  
}
```
### wait
wait必须在synchronized代码块中，同时释放对象的锁，等待notify/notifyAll 或者等待超时后重新获取的锁继续执行；
### sleep
sleep阻塞当前线程，不会释放锁。
### CAS
### synchronized
### volitale
# 8. 插件化
## 插件化换肤
### 拦截 View的创建过程
1. LayoutInflater 在通过反射创建View过程中，预留了接口（ Factory/Factory2）允许用户自定义创建过程；
2. Factory只允许被设置一次AppCompatActivity已经设置了一次，，Android 11之前都可以通过反射来修改mFactorySet值，现在我们只能在调用父类onCreate之前来设置Factory；
``` java
//LayoutInflater
public final View tryCreateView(@Nullable View parent, @NonNull String name,  
@NonNull Context context,  
@NonNull AttributeSet attrs) {  
    if (name.equals(TAG_1995)) {  
        // Let's party like it's 1995!  
        return new BlinkLayout(context, attrs);  
    }  
  
    View view;  
    if (mFactory2 != null) {  
        view = mFactory2.onCreateView(parent, name, context, attrs); //1 
    } else if (mFactory != null) {  
        view = mFactory.onCreateView(name, context, attrs);  
    } else {  
        view = null;  
    }  
  
    if (view == null && mPrivateFactory != null) {  
        view = mPrivateFactory.onCreateView(parent, name, context, attrs);  
    }  
    return view;  
}
public void setFactory2(Factory2 factory) {  
    if (mFactorySet) {  //2
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");  
    }  
    if (factory == null) {  
        throw new NullPointerException("Given factory can not be null");  
    }  
    mFactorySet = true;  
    if (mFactory == null) {  
        mFactory = mFactory2 = factory;  
    } else {  
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);  
    }  
}
```
### 加载插件的资源
参考原生的资源加载方式，直接利用插件apk路径 生成的AssetManager 构建Resource
``` java
public void loadSkin(String skinPath) {  
    if (TextUtils.isEmpty(skinPath)) {  
        //还原默认皮肤  
        SkinPreference.getInstance().reset();  
        SkinResources.getInstance().reset();  
    } else {  
        try {  
            //反射创建AssetManager 与 Resource        
            AssetManager assetManager = AssetManager.class.newInstance();  
            //资源路径设置 目录或压缩包  
            Method addAssetPath = assetManager.getClass().getMethod("addAssetPath",  
                    String.class);  
            addAssetPath.invoke(assetManager, skinPath);  
  
            //宿主app的 resources;            
            Resources appResource = mContext.getResources();  
            //根据当前的设备显示器信息 与 配置(横竖屏、语言等) 创建Resources  
            Resources skinResource = new Resources(assetManager, appResource.getDisplayMetrics(),  
                    appResource.getConfiguration());  
  
            //获取外部Apk(皮肤包) 包名  
            PackageManager mPm = mContext.getPackageManager();  
            PackageInfo info = mPm.getPackageArchiveInfo(skinPath, PackageManager.GET_ACTIVITIES);  
            String packageName = info.packageName;  
            SkinResources.getInstance().applySkin(skinResource, packageName);  
  
            //记录路径  
            SkinPreference.getInstance().setSkin(skinPath);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
    //通知采集的View 更新皮肤  
    //被观察者改变 通知所有观察者  
    setChanged();  
    notifyObservers(null);  
}
```
### 保存View与支持动态修改的属性列表mSkinViews
```java
private static final List<String> mAttributes = new ArrayList<>();  
  
static {  
    mAttributes.add("background");  
    mAttributes.add("src");  
    mAttributes.add("textColor");  
    mAttributes.add("drawableLeft");  
    mAttributes.add("drawableTop");  
    mAttributes.add("drawableRight");  
    mAttributes.add("drawableBottom");  
}
public void look(View view, AttributeSet attrs) {  
    List<SkinPair> mSkinPars = new ArrayList<>();  
  
    for (int i = 0; i < attrs.getAttributeCount(); i++) {  
        //获得属性名  textColor/background        String attributeName = attrs.getAttributeName(i);  
  
        if (mAttributes.contains(attributeName)) {  
            // 获取属性值  
            String attributeValue = attrs.getAttributeValue(i);  
            // 比如color 以#开头表示写死的颜色 不可用于换肤  
            if (attributeValue.startsWith("#")) {  
                continue;  
            }  
            int resId;  
            // 以 ？开头的表示使用 属性  
            if (attributeValue.startsWith("?")) {  
                int attrId = Integer.parseInt(attributeValue.substring(1));  
                resId = SkinThemeUtils.getResId(view.getContext(), new int[]{attrId})[0];  
            } else {  
                // 正常以 @ 开头  
                resId = Integer.parseInt(attributeValue.substring(1));  
            }  
            SkinPair skinPair = new SkinPair(attributeName, resId);  
            mSkinPars.add(skinPair);  
        }  
    }  
  
    if (!mSkinPars.isEmpty() || view instanceof SkinViewSupport) {  
        SkinView skinView = new SkinView(view, mSkinPars);  
        // 如果选择过皮肤 ，调用 一次 applySkin 加载皮肤的资源  
        skinView.applySkin();  
        mSkinViews.add(skinView);  
    }  
}
```
### 利用属性名称和类型在插件Resource中查找资源;
已知资源id 可以查找到对应的名称和类型，反之也可以查到对应的id；
``` java
public void applySkin() {  
    applySkinSupport();  
    for (SkinPair skinPair : skinPairs) {  
        Drawable left = null, top = null, right = null, bottom = null;  
        switch (skinPair.attributeName) {  
            case "background":  
                Object background = SkinResources.getInstance().getBackground(skinPair  
                        .resId);  
                //背景可能是 @color 也可能是 @drawable               
                 if (background instanceof Integer) {  
                    view.setBackgroundColor((int) background);  
                } else {  
                    ViewCompat.setBackground(view, (Drawable) background);  
                }  
                break;  
            case "src":  
                background = SkinResources.getInstance().getBackground(skinPair  
                        .resId);  
                if (background instanceof Integer) {  
                    ((ImageView) view).setImageDrawable(new ColorDrawable((Integer)  
                            background));  
                } else {  
                    ((ImageView) view).setImageDrawable((Drawable) background);  
                }  
                break;  
            case "textColor":  
                ((TextView) view).setTextColor(SkinResources.getInstance().getColorStateList  
                        (skinPair.resId));  
                break;            case "drawableLeft":  
                left = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableTop":  
                top = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableRight":  
                right = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            case "drawableBottom":  
                bottom = SkinResources.getInstance().getDrawable(skinPair.resId);  
                break;            default:  
                break;  
        }  
        if (null != left || null != right || null != top || null != bottom) {  
            ((TextView) view).setCompoundDrawablesWithIntrinsicBounds(left, top, right,  
                    bottom);  
        }  
    }  
}

public int getIdentifier(int resId){  
    if(isDefaultSkin){  
        return resId;  
    }  
    String resName=mAppResources.getResourceEntryName(resId);  
    String resType=mAppResources.getResourceTypeName(resId);  
    int skinId=mSkinResources.getIdentifier(resName,resType,mSkinPkgName);  
    return skinId;  
}  
  
/**  
 * 输入主APP的ID，到皮肤APK文件中去找到对应ID的颜色值  
 * @param resId  
 * @return  
 */  
public int getColor(int resId){  
    if(isDefaultSkin){  
        return mAppResources.getColor(resId);  
    }  
    int skinId=getIdentifier(resId);  
    if(skinId==0){  
        return mAppResources.getColor(resId);  
    }  
    return mSkinResources.getColor(skinId);  
}  
  
public ColorStateList getColorStateList(int resId) {  
    if (isDefaultSkin) {  
        return mAppResources.getColorStateList(resId);  
    }  
    int skinId = getIdentifier(resId);  
    if (skinId == 0) {  
        return mAppResources.getColorStateList(resId);  
    }  
    return mSkinResources.getColorStateList(skinId);  
}  
  
public Drawable getDrawable(int resId) {  
    if (isDefaultSkin) {  
        return mAppResources.getDrawable(resId);  
    }  
    //通过 app的resource 获取id 对应的 资源名 与 资源类型  
    //找到 皮肤包 匹配 的 资源名资源类型 的 皮肤包的 资源 ID  
      int skinId = getIdentifier(resId);  
    if (skinId == 0) {  
        return mAppResources.getDrawable(resId);  
    }  
    return mSkinResources.getDrawable(skinId);  
}

public Object getBackground(int resId) {  
    String resourceTypeName = mAppResources.getResourceTypeName(resId);  
  
    if ("color".equals(resourceTypeName)) {  
        return getColor(resId);  
    } else {  
        // drawable  
        return getDrawable(resId);  
    }  
}
```
## 双亲委派机制
1. 资源冲突: 1. 同名冲突 2继承带来的冲突？
2. Dropplugin 处理？
## Hook启动未注册Activity
###  替换为代理Activity
``` java
public static void hookAMS() {  
    try {  
        Class<?> clazz = Class.forName("android.app.ActivityTaskManager");  
        Field singletonField = clazz.getDeclaredField("IActivityTaskManagerSingleton");  
  
        singletonField.setAccessible(true);  
        Object singleton = singletonField.get(null);  
  
        Class<?> singletonClass = Class.forName("android.util.Singleton");  
        Field mInstanceField = singletonClass.getDeclaredField("mInstance");  
        mInstanceField.setAccessible(true);  
        Method getMethod = singletonClass.getMethod("get");  
        Object mInstance = getMethod.invoke(singleton);  
  
        Class IActivityTaskManagerClass = Class.forName("android.app.IActivityTaskManager");  
  
        Object mInstanceProxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),  
                new Class[]{IActivityTaskManagerClass}, new InvocationHandler() {  
                    @Override  
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
  
                        if ("startActivity".equals(method.getName())) {  
                            int index = -1;  
  
                            // 获取 Intent 参数在 args 数组中的index值  
                            for (int i = 0; i < args.length; i++) {  
                                if (args[i] instanceof Intent) {  
                                    index = i;  
                                    break;                                }  
                            }  
                            // 生成代理proxyIntent -- 孙悟空（代理）的Intent  
                            Intent proxyIntent = new Intent();  
                            // 这个包名是宿主的  
                            proxyIntent.setClassName("com.leo.amsplugin",  
                                    ProxyActivity.class.getName());  
  
                            // 原始Intent能丢掉吗？保存原始的Intent对象  
                            Intent intent = (Intent) args[index];  
                            proxyIntent.putExtra(TARGET_INTENT, intent);  
  
                            // 使用proxyIntent替换数组中的Intent  
                            args[index] = proxyIntent;  
                        }  
  
                        // 原来流程  
                        return method.invoke(mInstance, args);  
                    }  
                });  
  
        // 用代理的对象替换系统的对象  
        mInstanceField.set(singleton, mInstanceProxy);  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
}
```
### 启动成功后，将Intent换回目标Activity
``` java
public static void hookHandler() {  
    try {  
        Class<?> clazz = Class.forName("android.app.ActivityThread");  
  
        Field activityThreadField = clazz.getDeclaredField("sCurrentActivityThread");  
        activityThreadField.setAccessible(true);  
        Object activityThread = activityThreadField.get(null);  
  
        Field mHField = clazz.getDeclaredField("mH");  
        mHField.setAccessible(true);  
        final Handler mH = (Handler) mHField.get(activityThread);  
  
        Field mCallbackField = Handler.class.getDeclaredField("mCallback");  
        mCallbackField.setAccessible(true);  
  
        mCallbackField.set(mH, new Handler.Callback() {  
  
            @Override  
            public boolean handleMessage(Message msg) {  
                switch (msg.what) {  
                    case 159:  
                        // msg.obj = ClientTransaction  
                        try {  
                            // 获取 List<ClientTransactionItem> mActivityCallbacks 对象  
                            Field mActivityCallbacksField = msg.obj.getClass()  
                                    .getDeclaredField("mActivityCallbacks");  
                            mActivityCallbacksField.setAccessible(true);  
                            List mActivityCallbacks = (List) mActivityCallbacksField.get(msg.obj);  
  
                            for (int i = 0; i < mActivityCallbacks.size(); i++) {  
                                // 打印 mActivityCallbacks 的所有item:  
                                //android.app.servertransaction.WindowVisibilityItem                                //android.app.servertransaction.LaunchActivityItem  
                                // 如果是 LaunchActivityItem，则获取该类中的 mIntent 值，即 proxyIntent                                if (mActivityCallbacks.get(i).getClass().getName()  
                                        .equals("android.app.servertransaction.LaunchActivityItem")) {  
                                    Object launchActivityItem = mActivityCallbacks.get(i);  
                                    Field mIntentField = launchActivityItem.getClass()  
                                            .getDeclaredField("mIntent");  
                                    mIntentField.setAccessible(true);  
                                    Intent proxyIntent = (Intent) mIntentField.get(launchActivityItem);  
  
                                    // 获取启动插件的 Intent，并替换回来  
                                    Intent intent = proxyIntent.getParcelableExtra(TARGET_INTENT);  
                                    if (intent != null) {  
                                        mIntentField.set(launchActivityItem, intent);  
                                    }  
                                }  
                            }  
                        } catch (Exception e) {  
                            e.printStackTrace();  
                        }  
                        break;  
                }  
                return false;  
            }  
        });  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
  
}
```
## 加载资源
# 9. 热修复
# 10. View
## RecyclerView
### 四级缓存
``` java
public final class Recycler {  
    final ArrayList<ViewHolder> mAttachedScrap = new ArrayList<>();  
    ArrayList<ViewHolder> mChangedScrap = null;  
  
    final ArrayList<ViewHolder> mCachedViews = new ArrayList<ViewHolder>();  
  
    private int mRequestedCacheMax = DEFAULT_CACHE_SIZE;  
    int mViewCacheMax = DEFAULT_CACHE_SIZE;  
  
    RecycledViewPool mRecyclerPool;  
  
    private ViewCacheExtension mViewCacheExtension;
}
```
#### mAttachedScrap与mChangedScrap
用来缓存还在屏幕内的Holder，当数据集发生变化，触发重新布局，LayoutManager的onLayoutChildren方法会调用detachAndScrapAttachedViews先将屏幕上的View缓存起来；
#### mCachedViews
用来缓存移出屏幕之外的Holder，缓存上限是默认2个，采用FIFO结构，超出上限后，先加入的会被移除，会保留ViewHolder的数据和position，只能被同一position的Holder复用；
#### mViewCacheExtension
这个创建和缓存完全由开发者自己控制，系统未往这里添加数据，一般不使用
#### mRecyclerPool
缓存池，超过ViewCache的大小后，后移入到缓存池中，按照viewtype类型缓存，每个类型缓存大小默认为5个，缓存时会清空Holder
![[Pasted image 20230805110601.png]]
RecyclerView滑动时，刚开始的时候回收了Position0和Position1，它们被添加到了mCachedViews中。随后回收Position2时，达到数量上限，最先进入mCachedViews的Position0被放进了mRecyclerPool中。 再看下方进入可视区域的3个Item，最初的Position6和Position7找不到对应的缓存，只能新建ViewHolder并绑定。当Position8滑入可视区域时，发现mRecyclerPool中有一个ViewType相等的缓存，则将其取出并绑定数据进行复用。
### 参考链接
[RecyclerView缓存详解-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1914501?areaSource=102001.8&traceId=9QUB2Zmbr0FZd_YKdir2b)
## scrollTo 与 scrollBy
1. scrollBy 实际上也是调用的scrollTo;
2. scrollTo是相对原始坐标的距离，scrollBy 是绝对距离；
3. 滚动的原理是从新设置坐标，发起重绘，负数为增大坐标；
```java
public void scrollBy(int x, int y) {  
    scrollTo(mScrollX + x, mScrollY + y);  
}

public void scrollTo(int x, int y) {  
    if (mScrollX != x || mScrollY != y) {  
        int oldX = mScrollX;  
        int oldY = mScrollY;  
        mScrollX = x;  
        mScrollY = y;  
        invalidateParentCaches();  
        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  
        if (!awakenScrollBars()) {  
            postInvalidateOnAnimation();  
        }  
    }  
}
boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
	...
int sx = 0;  
int sy = 0;  
if (!drawingWithRenderNode) {  
    computeScroll();  
    sx = mScrollX;  
    sy = mScrollY;  
}  
  
final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;  
final boolean offsetForScroll = cache == null && !drawingWithRenderNode;  
  
int restoreTo = -1;  
if (!drawingWithRenderNode || transformToApply != null) {  
    restoreTo = canvas.save();  
}  
if (offsetForScroll) {  
    canvas.translate(mLeft - sx, mTop - sy);  
} else {
	....
}

```
# 11. okhttp
## 请求流程
## 连接池
``` kotlin
//RealConnectionPool
// 连接创建后立即加入连接池，开启守护线程进行轮询
fun put(connection: RealConnection) {  
  connection.assertThreadHoldsLock()  
  
  connections.add(connection)  
  cleanupQueue.schedule(cleanupTask)  
}


fun cleanup(now: Long): Long {  
    var inUseConnectionCount = 0  
    var idleConnectionCount = 0  
    var longestIdleConnection: RealConnection? = null  
    var longestIdleDurationNs = Long.MIN_VALUE  
    for (connection in connections) {  
        synchronized(connection) {  
            if (pruneAndGetAllocationCount(connection, now) > 0) {  // 判断当前链接有没有正在使用
                inUseConnectionCount++  
            } else {  
                idleConnectionCount++  
					  //如果不是正在是使用的链接，记录存活最长的链接
                val idleDurationNs = now - connection.idleAtNs  
                if (idleDurationNs > longestIdleDurationNs) {  
                    longestIdleDurationNs = idleDurationNs  
                    longestIdleConnection = connection  
                } else {  
                    Unit  
                }  
            }  
        }  
    }  
  
    when {  
    // 闲置链接的存活时间超过了最长时间（默认是五分钟） 或者闲置链接数超过了最大闲置连接数（默认是5个）
        longestIdleDurationNs >= this.keepAliveDurationNs  
                || idleConnectionCount > this.maxIdleConnections -> {  
            val connection = longestIdleConnection!!  
            synchronized(connection) {  
                if (connection.calls.isNotEmpty()) return 0L   
if (connection.idleAtNs + longestIdleDurationNs != now) return 0L   
connection.noNewExchanges = true  
                connections.remove(longestIdleConnection)  // 移除链接池
            }  
  
            connection.socket().closeQuietly()  //关闭socket
            if (connections.isEmpty()) cleanupQueue.cancelAll()  
            return 0L  
        }  
		  // 存在闲置，返回剩余时间
        idleConnectionCount > 0 -> {  
              
            return keepAliveDurationNs - longestIdleDurationNs  
        }  
		  // 只有正在使用的链接，返回最大闲置时间
        inUseConnectionCount > 0 -> {  
            return keepAliveDurationNs  
        }  
  
        else -> {  
            return -1  
        }  
    }  
}
//RealBackend
//通过wait实现的等待
override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {  
  val ms = nanos / 1_000_000L  
  val ns = nanos - (ms * 1_000_000L)  
  if (ms > 0L || nanos > 0) {  
    (taskRunner as Object).wait(ms, ns.toInt())  
  }  
}
```
## 建立HTTPS流程
``` kotlin
//RealConnection
fun connect(  
  connectTimeout: Int,  
  readTimeout: Int,  
  writeTimeout: Int,  
  pingIntervalMillis: Int,  
  connectionRetryEnabled: Boolean,  
  call: Call,  
  eventListener: EventListener  
) {  
  ...
  while (true) {  
    try {  
      if (route.requiresTunnel()) {  
        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)  
        if (rawSocket == null) {  
          // We were unable to connect the tunnel but properly closed down our resources.  
          break  
        }  
      } else {  
        connectSocket(connectTimeout, readTimeout, call, eventListener)  
      }  
      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)  
  ...
}
```
1. connectSockets 三次握手建立TCP连接，保存rawSocket；
2. establishProtocol 在TCP连接的基础上，开始不同版本的协议，来完成连接过程，主要有 HTTP/1.1，HTTP/2 和 SPDY 协议。如果是 HTTPS 类型的，则开始 TLS 建连。
``` kotlin
//Platform
open fun platformTrustManager(): X509TrustManager {  
// 默认TrustManager
  val factory = TrustManagerFactory.getInstance(  
      TrustManagerFactory.getDefaultAlgorithm())  
  factory.init(null as KeyStore?)  
  val trustManagers = factory.trustManagers!!  
  check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {  
    "Unexpected default trust managers: ${trustManagers.contentToString()}"  
  }  
  return trustManagers[0] as X509TrustManager  
}

open fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory { 
// 默认SslSocketFactory
  try {  
    return newSSLContext().apply {  
      init(null, arrayOf<TrustManager>(trustManager), null)  
    }.socketFactory  
  } catch (e: GeneralSecurityException) {  
    throw AssertionError("No System TLS: $e", e) // The system has no TLS. Just give up.  
  }  
}


//RealConnection
private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) {  
  val address = route.address  
  val sslSocketFactory = address.sslSocketFactory  
  var success = false  
  var sslSocket: SSLSocket? = null  
  try {  
    // 1
    sslSocket = sslSocketFactory!!.createSocket(  
        rawSocket, address.url.host, address.url.port, true /* autoClose */) as SSLSocket  
  
   //2 
    val connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)  
    if (connectionSpec.supportsTlsExtensions) {  
      Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)  
    }  

    sslSocket.startHandshake()  //3
    
    val sslSocketSession = sslSocket.session  
    val unverifiedHandshake = sslSocketSession.handshake()  
  
    // Verify that the socket's certificates are acceptable for the target host.  
    if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) {  
      val peerCertificates = unverifiedHandshake.peerCertificates  
      if (peerCertificates.isNotEmpty()) {  
        val cert = peerCertificates[0] as X509Certificate  
        throw SSLPeerUnverifiedException("""  
            |Hostname ${address.url.host} not verified:            |    certificate: ${CertificatePinner.pin(cert)}  
            |    DN: ${cert.subjectDN.name}  
            |    subjectAltNames: ${OkHostnameVerifier.allSubjectAltNames(cert)}  
            """.trimMargin())  
      } else {  
        throw SSLPeerUnverifiedException(  
            "Hostname ${address.url.host} not verified (no certificates)")  
      }  
    }  
  
    val certificatePinner = address.certificatePinner!!  
  
    handshake = Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,  
        unverifiedHandshake.localCertificates) {  
      certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,  
          address.url.host)  
    }  
  
    // Check that the certificate pinner is satisfied by the certificates presented.  
    certificatePinner.check(address.url.host) {  
      handshake!!.peerCertificates.map { it as X509Certificate }  
    }  
    // Success! Save the handshake and the ALPN protocol.  
    val maybeProtocol = if (connectionSpec.supportsTlsExtensions) {  
      Platform.get().getSelectedProtocol(sslSocket)  
    } else {  
      null  
    }  
    socket = sslSocket  
    source = sslSocket.source().buffer()  
    sink = sslSocket.sink().buffer()  
    protocol = if (maybeProtocol != null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1  
    success = true  
  } finally {  
    if (sslSocket != null) {  
      Platform.get().afterHandshake(sslSocket)  
    }  
    if (!success) {  
      sslSocket?.closeQuietly()  
    }  
  }  
}

//OkHttpClient
companion object {  
  internal val DEFAULT_PROTOCOLS = immutableListOf(HTTP_2, HTTP_1_1)  
  
  internal val DEFAULT_CONNECTION_SPECS = immutableListOf(  
      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)  
}
  //ConnectionSpecSelector
fun configureSecureSocket(sslSocket: SSLSocket): ConnectionSpec {  
  var tlsConfiguration: ConnectionSpec? = null  
  for (i in nextModeIndex until connectionSpecs.size) {  
    val connectionSpec = connectionSpecs[i]  
    if (connectionSpec.isCompatible(sslSocket)) {  
      tlsConfiguration = connectionSpec  
      nextModeIndex = i + 1  
      break  
    }  
  }  
  
  if (tlsConfiguration == null) {  
    // This may be the first time a connection has been attempted and the socket does not support  
    // any the required protocols, or it may be a retry (but this socket supports fewer protocols    // than was suggested by a prior socket).    throw UnknownServiceException("Unable to find acceptable protocols. isFallback=$isFallback," +  
        " modes=$connectionSpecs," +  
        " supported protocols=${sslSocket.enabledProtocols!!.contentToString()}")  
  }  
  
  isFallbackPossible = isFallbackPossible(sslSocket)  
  
  tlsConfiguration.apply(sslSocket, isFallback)  
  
  return tlsConfiguration  
}

//ConnectionSpec
internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) {  
  val specToApply = supportedSpec(sslSocket, isFallback)  
  
  if (specToApply.tlsVersions != null) {  
    sslSocket.enabledProtocols = specToApply.tlsVersionsAsString  
  }  
  
  if (specToApply.cipherSuites != null) {  
    sslSocket.enabledCipherSuites = specToApply.cipherSuitesAsString  
  }  
}

@JvmField  
val MODERN_TLS = Builder(true)  
    .cipherSuites(*APPROVED_CIPHER_SUITES)  
    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)  
    .supportsTlsExtensions(true)  
    .build()
```
1. 建立安全Socket ,Okhttp采用的系统默认的实现，与平台是强相关的。
2. 配置SSLSocket，主要包含2个部分：1. 支持的TLS协议	2. 支持的密码套件；okhttp内置三套规格，默认采用DEFAULT_CONNECTION_SPECS，ConnectionSpecSelector会遍历选择当前支持的规格后设置Socket;
3.  开始握手：正式向服务端发出数据包，内容为可选择的密码和请求证书。服务端会返回响应的密码套件，tls版本，节点证书，本地证书等等，封装在Handshake类中；
	- **CipherSuite**， 密码套件。
	- **TlsVersion**， TLS 版本。
	- **Certificate[] peerCertificates**， 站点的证书。
	- **Certificate[] localCertificates**， 本地的证书。一些安全级别更高的应用，会使用双向的证书认证。
4. 验证
	1. 站点身份验证HostnameVerifier，默认实现是OkHostnameVerifier，主要是检查证书里的IP与hostname是否是我们的目标地址；
	2. 证书锁定
## 参考连接
[懂了，原来 OkHttp 是这样建立 HTTPS 连接的 - 简书](https://www.jianshu.com/p/f7972c30fc52)
[面试突击：OkHttp 原理八连问-51CTO.COM](https://www.51cto.com/article/689330.html)
# Activity的启动流程
## 跨进程启动
以Launcher启动一个应用为例，涉及四个进程通信
1. Launcher进程调用系统服务ATMS启动Activity;
2. ATMS判断当前应用进程不存在，调用AMS通过socket通知zygote进程fork出应用进程
3. 应用进程创建成功，通过反射创建Application对象，并将当前的进程的binder对象 ApplicationThread 交给AMS;
4. AMS保存进程信息，并持有应用进程的binder，利用这个binder对象，创建Activity，并调用其生命周期方法；