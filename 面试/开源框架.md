# OkHttp
1. 请求的执行流程：构建请求 -> 分发器 -> 拦截器 -> 获得响应；
2. 分发器：内部维护队列与线程池，用来控制请求数与请求线程；
3. 拦截器：完成请求；
	1. RetryAndFollowUpInterceptor：重试与重定向
	2. BridgeInterceptor：桥接拦截器
	3. CacheInterceptor：缓存拦截器
	4. ConnectInterceptor：连接拦截器
	5. CallServerInterceptor：请求服务器拦截器
## RetryAndFollowUpInterceptor
1. 重试用来处理特定的IO异常和路由异常
	1. 重试是可配置
	2. 部分异常如协议异常，握手异常 证书异常 不能重试
	3. 存在更多路径选择，DNS解析返回了多个IP ，挨个重试` RouteSelector#resetNextInetSocketAddress`
2. 重定向 针对特定的返回码重新请求
	1. 407 客户端使用了代理，需要添加Proxy-Authorization请求头，并配置密码；
	2. 308：永久重定向，并且请求为Get形式
## BridgeInterceptor
1. 补全请求头，HOST/User-Agent等
2.  对于使用Gzip 返回的响应，会通过GzipSource 之后 用于下游解析
## CacheInterceptor
## ConnectInterceptor
1. 所谓的连接就是指一个Socket， 该拦截器的主要作用 就是维护一个连接池；
2. 连接被创建成功后会加入到连接队列中，并开启一个线程轮询检查队列；
3. 最大闲置数为五个，最长闲置时间为五分钟，超过之后按时间顺序清理，不满足条件则线程等待
## CallServerInterceptor

# 插件化
## 自定义ClassLoader
`SystemClassLoaderAdder  NewClassLoaderInjector.inject`
# 插件化换肤
# Glide
1. 生命周期管理
	1.  android x之前，和当前Androidx的实现方式类似，通过向当前页面中加入空白Fragment来实现跟随Activity的生命周期
	2. androidx之后，activity实现LifecyclerOwner接口，只需要将RequestManager加入到观察者列表中就能跟随Activty生命周期
	3.  不建议使用ApplicatioContext和子线程中中初始化Glide，这样生命周期无法保证；
2. 缓存管理
	1. 活动缓存: 当前页面缓存
		1. 当前页面上的资源到采用引用队列+弱引用的形式 保存在集合中，用于使用；
		2. 活动缓存创建时，会开启守护线程遍历引用队列，页面销毁时， 回收活动缓存加入到LRU列表中；
	3. 内存缓存：LRU算法
	4. 磁盘缓存：
3. Glide 加载gif的优化
	1. 
# Jetpack
## Lifecycle

1. Lifecycle 是对观察者模式的应用，被观察中保存观察列表，状态发生变化时，遍历列表，通知观察者。
2. androidx之后，Activity默认实现了LifecycleOwner接口，创建被返回了LifecycleRegistry对象，这个对象默认会保存观察者列表。
3. 通知观察者时，不是由Activity直接通知，而是通过向页面向加入空白Fragment  由Fragment生命周期变化来通知观察者；
4. 事件驱动状态
	1. Activity生命周期六个事件：ON_CREATE -> ON_START-> ON_RESUME ->ON_PAUSE -> ON_STOP-> ON_DESTROY
	2. 状态按照枚举大小排序：DESTROYED  INITIALIZED CREATED STARTED RESUMED
	3. onCreate和onStop事件都对应了ON_CREATE状态，如果事件状态比当前的大，说明状态要增大，只能是Activity触发了ON_CREATE生命周期，
## LiveData
1. LiveData 也是基于Lifecycle实现，数据发生变化时，可以通知观察者，并保证了Activity在onResumed状态时才通知。
2. 粘性事件：第二Activity启动时，会接受的LiveData的最后一次数据变化的通知；
		1. 观察者通过比较自身与数据的版本号来确定数据是否接受过；
		2. 同一个Livedata数据，肯定比第二个Activity中创建的观察者版本号大；
		3. 反射修改观察者的版本号；
``` java
        private void hook(Observer<? super T> observer) {
            try {
                // TODO 1.得到mLastVersion
                // 获取到LivData的类中的mObservers对象
                Class<LiveData> liveDataClass = LiveData.class;
                Field mObserversField = liveDataClass.getDeclaredField("mObservers");
                mObserversField.setAccessible(true);
                // 获取到这个成员变量的对象
                Object mObserversObject = mObserversField.get(this);
                // 得到map对象的class对象
                Class<?> mObserversClass = mObserversObject.getClass();
                // 获取到mObservers对象的get方法
                Method get = mObserversClass.getDeclaredMethod("get", Object.class);
                get.setAccessible(true);
                // 执行get方法
                Object invokeEntry = get.invoke(mObserversObject, observer);
                // 取到entry中的value
                Object observerWraper = null;
                if (invokeEntry != null && invokeEntry instanceof Map.Entry) {
                    observerWraper = ((Map.Entry) invokeEntry).getValue();
                }
                if (observerWraper == null) {
                    throw new NullPointerException("observerWraper is null");
                }
                // 得到observerWraperr的类对象
                Class<?> supperClass = observerWraper.getClass().getSuperclass();
                Field mLastVersion = supperClass.getDeclaredField("mLastVersion");
                mLastVersion.setAccessible(true);

                // TODO 2.得到mVersion
                Field mVersion = liveDataClass.getDeclaredField("mVersion");
                mVersion.setAccessible(true);

                // TODO 3.mLastVersion=mVersion
                Object mVersionValue = mVersion.get(this);
                mLastVersion.set(observerWraper, mVersionValue);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
```
## DataBinding

# Leakcanary
1. 弱引用+引用队列的形式，弱引用被回收时，会加入到引用队列中，与map中的对象比较，依然存活的对象，判断为内存泄漏 触发GC 后dump信息
2. 如果判断对象是否可以被回收
	1. Activity ：注册`Application.ActivityLifecycleCallbacks`监听所有Activity destroy
		1. 只能监听生命周期的回调时 触发的内存泄漏
	2. Fragment :`fragmentManager.registerFragmentLifecycleCallbacks`
		1. 缺点 对于嵌套Fragment 无法处理
	3. Service
	4. View
# 插件化
## 类的加载
## 四大组件
## so的动态加载
1. so的加载方法：System.loadLibrary和System.load， 前者是通过在当前ClassLoader的nativelibrary路径中查找，后者是通过指定路径去查找
2. 正常的apk应用安装时，so就会被拷贝到应用私有目录下。
## 插件化换肤
## 参考链接
- [我填坑了 - ​Android动态加载so，再次完善](https://mp.weixin.qq.com/s/TgPr2tKP61rUNDAx3kzOmg)
- [​Android动态加载so！这一篇就够了！](https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650844746&idx=1&sn=2de540ae86befbba436355278c14d04c&chksm=80b77ad4b7c0f3c272dae9b9904e995679d8118ea87a22ec86d4c991adafe9a5394cdd1565f3&scene=21#wechat_redirect)
- [动态下发 so 库在 Android APK 安装包瘦身方面的应用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1592672?from=article.detail.1751968)