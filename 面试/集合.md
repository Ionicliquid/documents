# ConcurrentHashMap
## put
``` java
final V putVal(K key, V value, boolean onlyIfAbsent) {  
    if (key == null || value == null) throw new NullPointerException();  
    int hash = spread(key.hashCode());  //1
    int binCount = 0;  
    for (Node<K,V>[] tab = table;;) {  
        Node<K,V> f; int n, i, fh; K fk; V fv;  
        if (tab == null || (n = tab.length) == 0)  //2
            tab = initTable();  
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {  //3
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))  
                break;                   // no lock when adding to empty bin  
        }  
        else if ((fh = f.hash) == MOVED)  //4
            tab = helpTransfer(tab, f);  
        else if (onlyIfAbsent // check first node without acquiring lock  
                 && fh == hash  
                 && ((fk = f.key) == key || (fk != null && key.equals(fk)))  
                 && (fv = f.val) != null)  
            return fv;  
        else {  
            V oldVal = null;  
            synchronized (f) {  //5
                if (tabAt(tab, i) == f) {  
                    if (fh >= 0) {  
                        binCount = 1;  
                        for (Node<K,V> e = f;; ++binCount) {  
                            K ek;  
                            if (e.hash == hash &&  
                                ((ek = e.key) == key ||  
                                 (ek != null && key.equals(ek)))) {  
                                oldVal = e.val;  
                                if (!onlyIfAbsent)  
                                    e.val = value;  
                                break;                            }  
                            Node<K,V> pred = e;  
                            if ((e = e.next) == null) {  
                                pred.next = new Node<K,V>(hash, key, value);  
                                break;                            }  
                        }  
                    }  
                    else if (f instanceof TreeBin) {  
                        Node<K,V> p;  
                        binCount = 2;  
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,  
                                                       value)) != null) {  
                            oldVal = p.val;  
                            if (!onlyIfAbsent)  
                                p.val = value;  
                        }  
                    }  
                    else if (f instanceof ReservationNode)  
                        throw new IllegalStateException("Recursive update");  
                }  
            }  
            if (binCount != 0) {  
                if (binCount >= TREEIFY_THRESHOLD)  
                    treeifyBin(tab, i);  
                if (oldVal != null)  
                    return oldVal;  
                break;            }  
        }  
    }  
    addCount(1L, binCount);  
    return null;}
```
1. 根据 key 计算出 hashcode；
2. 判断是否需要进行初始化；
3. 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。
5.  如果都不满足，则利用 synchronized 锁写入数据。
6. 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。
## 扩容
### tryPresize
``` java

private final void treeifyBin(Node<K,V>[] tab, int index) {  
    Node<K,V> b; int n;  
    if (tab != null) {  
        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)  
            tryPresize(n << 1);  
        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {  
            synchronized (b) {  
                if (tabAt(tab, index) == b) {  
                    TreeNode<K,V> hd = null, tl = null;  
                    for (Node<K,V> e = b; e != null; e = e.next) {  
                        TreeNode<K,V> p =  
                            new TreeNode<K,V>(e.hash, e.key, e.val,  
                                              null, null);  
                        if ((p.prev = tl) == null)  
                            hd = p;  
                        else                            tl.next = p;  
                        tl = p;  
                    }  
                    setTabAt(tab, index, new TreeBin<K,V>(hd));  
                }  
            }  
        }  
    }  
}

private final void tryPresize(int size) {  
    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :  
        tableSizeFor(size + (size >>> 1) + 1);  
    int sc;  
    while ((sc = sizeCtl) >= 0) {  
        Node<K,V>[] tab = table; int n;  
        if (tab == null || (n = tab.length) == 0) {  
            n = (sc > c) ? sc : c;  
            if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {  
                try {  
                    if (table == tab) {  
                        @SuppressWarnings("unchecked")  
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];  
                        table = nt;  
                        sc = n - (n >>> 2);  
                    }  
                } finally {  
                    sizeCtl = sc;  
                }  
            }  
        }  
        else if (c <= sc || n >= MAXIMUM_CAPACITY)  
            break;  
        else if (tab == table) {  
            int rs = resizeStamp(n);  
            if (U.compareAndSetInt(this, SIZECTL, sc,  
                                    (rs << RESIZE_STAMP_SHIFT) + 2))  
                transfer(tab, null);  
        }  
    }  
}

private static final int tableSizeFor(int c) {  
    int n = -1 >>> Integer.numberOfLeadingZeros(c - 1);  
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;  
}
```