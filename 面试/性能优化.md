# 启动优化

![[应用的启动阶段.png]]
1. 首先是从理论分析可以有哪些优化点
	1.  App进程启动阶段： Zygote fork进程
	2. Application创建阶段：bindApplication  -> attachBaseContext -> installProvider -> Application:onCreate
	3. handler间隙:handlerMessage
	4. Activity创建阶段：Activity的生命周期 ->View构建 -> View渲染
	5. 数据加载：数据加载与绑定UI阶段
## 现状分析
启动时间的统计：
1. profiler 
2. adb
3. 通过代码dump；控制起始和终止
## 具体的启动项优化
1. 进程的创建：黑白屏控制
2. Application的创建
	1. bindApplication: 创建Application
	2. attachBaseContext：<font color="#c00000"> 类加载优化？</font>
	3. installProvider: provider会在Application创建前初始化，比如Leakcanary
	4. onCreate: 生命周期，异步初始化SDK，<font color="#c00000">Android Start up</font>
3. handler间隙： 监控主线程的相关消息堆主线程消息进行初始化：一些三方SDK可能在初始化时使用主线程的handler
4. Activity的生命周期
	1. 减少逻辑的复杂度
	2. View的层级优化，优化绘制速度：
		1.  替换RelativeLayout 为ConstraintLayout，前者会多次测量；
		2. 如果根布局是FrameLayout的布局，我们可以使用merge标签减少一层布局；
	3. IdleHandler ：合理使用进行延迟初初始化
5. 数据加载：
	1. 数据预加载：广告页与闪屏页 预加载数据
	2.  数据缓存： 
	3. 显示数据优先级调度
## 持续的线上线下测试
1. 埋点 统计启动时长
# 内存优化
 1. minorGC  FullGC的区别？
 2. 对象晋升到老年代的条件？
 3. 4大引用
 4. 垃圾回收算法？
 5. 分代收集理论
 6. private属性和默认属性，内部类的访问方式是不同的，前者是直接访问（看字节码
 7. 热修复技术 ：loader.findLibrary 直接根据so库的名称去查找so
# APM
线上监控卡顿的方案
1. matrix/ BlockCanary : Looper#setMessageLogging 设置消息打印工具，同居消息执行时间；
	1. BlockCanary只监控粒度比较粗，只能定位到message耗时，不能定位到具体的方法，matrix 通过字节码插桩，记录每个方法的运行时间；
	2. matrix bugly都允许上传map文件 来还原混淆的代码定位到真实的方法；
	3. matrix 统计方法的细节？
2. Ch