# Java
1. JVM的内存管理
	1. 虚拟机栈/本地方法栈
		1. 线程私有，每个方法执行都会产生一个栈帧入栈，栈帧的四大区域
			1. 局部变量表
			2. 操作数栈
			3. 返回地址
			4. 动态链接
	2. 程序计数器：线程私有：当前线程字节码执行的行号指示器
	3. 堆：几乎所有的对象都在此分配
	4. 方法区
	5. 运行时常量池
2. 对象的创建过程
3. 垃圾回收机制
	1. 分代收集理论
	2. 垃圾回收算法
		1.  标记清除
		2.  标记复制
		3.  标记整理
4. 线程池
5. synchronized关键字
6. volitale关键字
7. 4大引用
# Android
# handler
1. 消息机制三个对象
	1. Looper 轮询从消息队列中取消息来处理，主线程的Looper 在应用启动时已经开启了循环，子线程的Looper需要手动开启
	2. MessageQueue 消息队列 保存消息，实际上是一个按照时间排序的双向链表
	3. Handler 向消息队列中发送消息
	4. Message 中的target属性指向发送它的handler ，message会交给对应的handler处理。
# 事件的传递机制
1. 一个事件序列  1个down 多个move 一个up或者cancel组成
2. 事件的传递顺序 从window -> Activity -> ViewGroup ->View
3. 核心方法 dispatchTouchEvent -> onInterceptTouchEvent -> onTouchEvent 依次执行
4. 一个down事件传递到ViewGroup 的dispatch方法 首先检查intercept是否拦截 如果不拦截，遍历所有的子View, 找到处理该down事件的View 并保存在链表中，总结就是 一个View如果处理down事件 也不会处理到其他事件。
# okhttp
1. 拦截器模式
# Leakcanary/Koom
1. 对象没有及时回收，在Android中具有生命周期的对象都可能发生内存泄漏
2. 在对象被销毁时，将对象封装成弱引用关联到引用队列中，按照弱引用队列的特性，如果对象被回收，则队列中存在该对象，5s后，检查引用队列 如果存在对象，说明已经泄漏，dump 堆快照进行引用链分析。
	
# 插件化
1. class文件
2. 资源文件
3. so文件
# jetpack
1. lifecycle
2. LiveData
# 架构设计
1. MVVM
2. WebView的重构
3. 组件化思想